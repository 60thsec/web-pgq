/* jshint node:true */
"use strict";

var events = require('events');
var util = require('util');

var _ = require('lodash');
var logging = require('omega-logger');
var pg = require('pg');
var pgTypes = require('pg').types;
var Promise = require('bluebird');

// --------------------------------------------------------------------------------------------------------------------

var logger = logging.loggerFor(module);

// Type OIDs for built-in types we need to know about.
var byteaTypeOID = 17;

// --------------------------------------------------------------------------------------------------------------------

/**
 * Connect to the given database.
 *
 * @param {object} connectionInfo - `node-postgres` connection options
 *
 * @returns {Promise.<Connection>} - a promise for the open connection object
 */
function connect(connectionInfo)
{
    return Promise.try(function()
    {
        // Set the connection's application name so we can be identified by server admins.
        connectionInfo.application_name = 'web-pgq';

        var client = new pg.Client(connectionInfo);

        var conn = new Connection(connectionInfo, client, client.end.bind(client));

        return Promise.promisify(client.connect.bind(client))()
            .tap(function()
            {
                logger.info("Connected to %j", connectionInfo);
            })
            .then(conn.getSettings.bind(conn))
            .then(conn.getTypes.bind(conn))
            .return(conn);
    })
    .catch(function(error)
    {
        logger.error("Error connecting to %j: %s", connectionInfo, error.stack || error);
        throw error;
    });
} // end connect

// --------------------------------------------------------------------------------------------------------------------

/**
 * Wraps a PostgreSQL connection.
 *
 * @param {object} connectionInfo - `node-postgres` connection options
 * @param {pg.Client} client - the `node-postgres` client
 * @param {function} done - the function to release the client to the `node-postgres` pool
 */
function Connection(connectionInfo, client, done)
{
    this.connectionInfo = connectionInfo;
    this.client = client;
    this.done = done;

    this.onError = this.onError.bind(this);
    this.onNotice = this.onNotice.bind(this);
    this.onEnd = this.onEnd.bind(this);

    this.client
        .on('error', this.onError)
        .on('notice', this.onNotice)
        .on('end', this.onEnd);
} // end Connection

util.inherits(Connection, events.EventEmitter);

/**
 * The definition of a batch of PostgreSQL queries.
 *
 * @typedef {object} Connection#BatchDef
 *
 * @property {*} queryID - the ID of the query batch (an arbitrary value provided by the client)
 * @property {Array.<Connection#QueryDef>} queries - the collection of queries to run
 * @property {boolean} [rollback] - if not undefined, run the queries in a transaction; if true, roll it back instead
 *          of committing when all finish successfully
 */

/**
 * The definition of a PostgreSQL query.
 *
 * @typedef {object} Connection#QueryDef
 * @see {@link https://github.com/brianc/node-postgres/wiki/Prepared-Statements}
 *
 * @property {string} [name] - if supplied, creates or uses a prepared statement with the given name
 * @property {string} [text] - the text of the SQL query to run or prepare (required unless using a prepared statement)
 * @property {Array} [values] - the values of the query parameters
 */

/**
 * The results of a PostgreSQL query.
 *
 * @typedef {object} Connection#QueryResults
 *
 * @property {number} rowCount - the number of rows in the result set
 * @property {number} affectedRowCount - the number of affected rows reported by the database
 * @property {number} totalTimeMS - the total time the query took to run, in milliseconds
 */

/**
 * The results of a batch of PostgreSQL queries.
 *
 * @typedef {object} Connection#BatchResults
 *
 * @property {string} status - the final status of the batch; one of: `"committed"`, `"committed (no transaction)"`, or
 *          `"rolled back"`
 * @property {number} totalTimeMS - the total time the batch took to run, in milliseconds
 * @property {Array.<Connection#QueryResults>} queryResults - the results object of each query, with some extra
 *          information attached
 */

/**
 * A row has been generated by a database query.
 *
 * @event Connection#row
 *
 * @param {*} queryID - the ID of the query that generated this row
 * @param {object} row - the row
 */

/**
 * An error occurred on this connection.
 *
 * @event Connection#error
 *
 * @param {object} error - the error that occurred
 */

Object.defineProperty(Connection.prototype, 'remoteAddress', {
    enumerable: true,
    get: function()
    {
        return this.client && this.client.connection.stream.remoteAddress;
    } // end get
}); // end Connection#remoteAddress

/**
 * "Close" this connection.
 *
 * Actually, this releases the underlying client back to the to the `node-postgres` pool, unless `error` is passed.
 *
 * @param {object} error - a fatal connection error that occurred; forces the connection to be closed instead of being
 *          returned to the pool
 */
Connection.prototype.close = function(error)
{
    if(!this.client)
    {
        // We've already cleaned up.
        return;
    } // end if

    this.done(error);

    if(!error)
    {
        // Since we're just returning the client to the pool, we need to clean up here instead of in #onEnd().
        this.client
            .removeListener('error', this.onError)
            .removeListener('notice', this.onNotice)
            .removeListener('end', this.onEnd);

        delete this.client;
        delete this.done;
    } // end if
}; // end Connection#close

Connection.prototype.onError = function(error)
{
    logger.error("Connection-level error: %s", error.stack || logger.dump(error));
    this.emit('error', error);

    // Since this is a connection-level error, close the connection instead of returning it to the pool.
    this.close(error);
}; // end Connection#onError

Connection.prototype.onNotice = function(notice)
{
    logger.info("Notice from PostgreSQL: %s", logger.dump(notice));
    this.emit('notice', notice);
}; // end Connection#onNotice

Connection.prototype.onEnd = function()
{
    logger.info("Connection ended.");

    if(this.client)
    {
        this.client
            .removeListener('error', this.onError)
            .removeListener('notice', this.onNotice)
            .removeListener('end', this.onEnd);
    } // end if

    delete this.client;
    delete this.done;

    this.emit('disconnected');
}; // end Connection#onEnd

Connection.prototype.getSettings = function()
{
    var self = this;
    this.settings = {};
    this.settingDescriptions = {};
    var queryDef = {text: "SHOW ALL"};

    return this._query(queryDef, function(row)
    {
        self.settings[row.name] = row.setting;
        self.settingDescriptions[row.name] = row.description;
    })
    .then(function()
    {
        logger.trace("server settings = %s", logger.dump(self.settings));
        return self.settings;
    });
}; // end Connection#getSettings

Connection.prototype.getTypes = function()
{
    var self = this;
    this.types = {};
    var queryDef = {text: "SELECT t.oid, COALESCE(an.nspname, n.nspname) AS nspname, COALESCE(at.typname, t.typname) AS typname, t.typcategory, n.nspname, t.typname FROM pg_type t LEFT JOIN pg_namespace n ON n.oid = t.typnamespace LEFT JOIN pg_type at ON at.oid = t.typelem LEFT JOIN pg_namespace an ON an.oid = at.typnamespace WHERE t.typtype = 'b' ORDER BY t.oid"};

    return this._query(queryDef, function(row)
    {
        var typeOID = row.oid;
        var typeName = (row.nspname == 'pg_catalog' ? '' : row.nspname + '.') + row.typname +
            (row.typcategory == 'A' ? '[]' : '');

        self.types[typeOID] = typeName;

        switch(typeName)
        {
            case 'public.geometry':
                logger.debug("Setting type parser for data type %s (oid=%s) to that of `bytea`.",
                    logger.dump(typeName), logger.dump(typeOID));

                pgTypes.setTypeParser(typeOID, 'text', pgTypes.getTypeParser(byteaTypeOID));
                break;
        } // end switch
    })
    .then(function()
    {
        return self.types;
    });
}; // end Connection#getTypes

Connection.prototype._query = function(queryDef, onRow)
{
    var self = this;

    onRow = onRow || function(row, result)
    {
        result.addRow(row);
    }; // end default onRow;

    if(!self.client)
    {
        return Promise.reject(new Error("Connection has been closed! Can't run query " + util.inspect(queryDef)));
    } // end if

    return new Promise(function(resolve, reject)
    {
        var query = self.client.query(queryDef)
            .on('error', onError)
            .on('row', onRow)
            .on('end', onEnd);

        function onError(error)
        {
            logger.error("Connection#_query got error: %s", error.stack || error);

            reject(error);

            query
                .removeListener('error', onError)
                .removeListener('row', onRow)
                .removeListener('end', onEnd);
        } // end onError

        function onEnd(result)
        {
            resolve(result);

            query
                .removeListener('error', onError)
                .removeListener('row', onRow)
                .removeListener('end', onEnd);
        } // end onEnd
    });
}; // end Connection#_query

/**
 * Execute a batch of queries on this PostgreSQL connection.
 *
 * @param {Connection#BatchDef} batchDef - the definition of the batch of queries to run
 *
 * @returns {Promise.<Connection#BatchResults>} - a promise for the results object of each query once all queries are
 *          finished, with some extra information attached
 */
Connection.prototype.query = function(batchDef)
{
    var self = this;

    var queryID = batchDef.queryID;
    var statementNum = 0;

    var queries = batchDef.queries.slice();
    function runNext()
    {
        var query;
        while(!query && queries.length > 0)
        {
            query = queries.shift();
        } // end while

        if(!query)
        {
            return Promise.resolve([]);
        } // end if

        return doQuery(query)
            .then(function(result)
            {
                if(queries.length > 0)
                {
                    return runNext()
                        .then(function(nextResults)
                        {
                            return [result].concat(nextResults);
                        });
                }
                else
                {
                    return [result];
                } // end if
            });
    } // end runNext

    var batchStartTime = process.hrtime();
    if(batchDef.rollback !== undefined)
    {
        // Run the queries in the batch inside a transaction.
        return self.beginTransaction()
            .then(function()
            {
                return runNext()
                    .tap(function()
                    {
                        return (batchDef.rollback ? self.rollback() : self.commit());
                    })
                    .catch(function(error)
                    {
                        return self.rollback()
                            .finally(function()
                            {
                                throw error;
                            });
                    });
            }) // end .then callback
            .then(buildBatchResults(batchDef.rollback ? "rolled back" : "committed"));
    }
    else
    {
        // Run the queries _without_ a trasaction. (on error, the results of some queries in the batch may still have
        // been committed!)
        return runNext()
            .then(buildBatchResults("committed (no transaction)"));
    } // end if

    // Build the Connection#BatchResults object for a successful response.
    function buildBatchResults(status)
    {
        return function(queryResults)
        {
            var totalTime = process.hrtime(batchStartTime);
            var totalTimeMS = totalTime[0] * 1e3 + totalTime[1] / 1e6;

            return {
                status: status,
                queryResults: queryResults,
                totalTimeMS: totalTimeMS
            };
        };
    } // end buildBatchResults

    // Run an individual query from this batch.
    function doQuery(queryDef)
    {
        if(!_.has(queryDef, 'rowMode'))
        {
            queryDef.rowMode = "array";
        } // end if

        return new Promise(function(resolve, reject)
        {
            statementNum += 1;

            logger.info("Running query %j of batch %j...", statementNum, queryID);
            logger.trace("Query %j#%j: %s", queryID, statementNum, logger.dump(queryDef));

            var startTime = process.hrtime();
            var query = self.client.query(queryDef)
                .on('error', onError)
                .on('row', onRow)
                .on('end', onEnd);

            function onError(error)
            {
                logger.error("Query %j got error: %s", queryID, error.stack || error);

                error.queryID = queryID;
                error.statementNum = statementNum;

                reject(error);

                query
                    .removeListener('error', onError)
                    .removeListener('row', onRow)
                    .removeListener('end', onEnd);
            } // end onError

            var fieldsEmitted = false;
            function emitFields(fields)
            {
                if(!fieldsEmitted && fields)
                {
                    logger.info("Emitting `fields` event with queryID = %s, statementNum = %s",
                        logger.dump(queryID), logger.dump(statementNum));

                    self.emit('fields', queryID, statementNum, fields.map(function(field)
                    {
                        field.dataType = self.types[field.dataTypeID];
                        return field;
                    }));

                    fieldsEmitted = true;
                } // end if
            } // end emitFields

            function onRow(row, result)
            {
                emitFields(result.fields);

                result.returnedRowCount = (result.returnedRowCount || 0) + 1;

                self.emit('row', queryID, statementNum, row);
            } // end onRow

            function onEnd(result)
            {
                var totalTime = process.hrtime(startTime);
                var totalTimeMS = totalTime[0] * 1e3 + totalTime[1] / 1e6;

                result.returnedRowCount = result.returnedRowCount || 0;

                logger.info("Query %j finished. (%s row%s returned, %s row%s affected)", queryID,
                    result.returnedRowCount, result.returnedRowCount == 1 ? '' : 's',
                    result.rowCount, result.rowCount == 1 ? '' : 's'
                );

                emitFields(result.fields);

                var response = _.assign(
                    {
                        rowCount: result.returnedRowCount,
                        affectedRowCount: result.rowCount,
                        totalTimeMS: totalTimeMS
                    },
                    _.omit(result, 'returnedRowCount', 'rowCount', 'rows')
                );
                logger.trace("response: %s", logger.dump(response));

                resolve(response);

                query
                    .removeListener('error', onError)
                    .removeListener('row', onRow)
                    .removeListener('end', onEnd);
            } // end onEnd
        }); // end Promise callback
    } // end doQuery
}; // end Connection#query

/**
 * Begin a transaction.
 *
 * @returns {Promise} - a promise for when the transaction has started
 */
Connection.prototype.beginTransaction = function()
{
    var self = this;

    return self._query('BEGIN TRANSACTION', function() {})
        .catch(function(error)
        {
            return self.rollback()
                .finally(function()
                {
                    throw error;
                });
        });
}; // end Connection#beginTransaction

/**
 * Roll back the current transaction.
 *
 * @returns {Promise} - a promise for when the transaction has been rolled back
 */
Connection.prototype.rollback = function()
{
    var self = this;

    return self._query('ROLLBACK', function() {})
        .catch(function(error)
        {
            // Quoting the node-postgres wiki:
            // "if there was a problem rolling back the query something is seriously messed up."

            // Since the connection is most likely in a bad state, close it instead of returning it to the pool.
            self.close(error);

            throw error;
        });
}; // end Connection#rollback

/**
 * Commit the current transaction.
 *
 * @returns {Promise} - a promise for when the transaction has been committed
 */
Connection.prototype.commit = function()
{
    var self = this;

    return self._query('COMMIT', function() {})
        .catch(function(error)
        {
            // Errors committing a transaction are also a sign that something is pretty messed up.
            // Since the connection is most likely in a bad state, close it instead of returning it to the pool.
            self.close(error);

            throw error;
        });
}; // end Connection#commit

// --------------------------------------------------------------------------------------------------------------------

module.exports = {
    connect: connect,
    Connection: Connection
};
