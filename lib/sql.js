var events = require('events');
var util = require('util');

var _ = require('lodash');
var logging = require('omega-logger');
var pg = require('pg');
var pgTypes = require('pg').types;
var Promise = require('bluebird');

// --------------------------------------------------------------------------------------------------------------------

var logger = logging.loggerFor(module);

// Type OIDs for built-in types we need to know about.
var byteaTypeOID = 17;

// --------------------------------------------------------------------------------------------------------------------

/**
 * Connect to the given database.
 *
 * @todo Document parameters.
 */
function connect(connectionInfo)
{
    return new Promise(function(resolve, reject)
    {
        // Set application_name on the connection.
        connectionInfo.application_name = connectionInfo.application_name || 'web-pgq';

        pg.connect(connectionInfo, function(error, client, done)
        {
            if(error)
            {
                logger.error("Error connecting to %j: %s", connectionInfo, error.stack || error);

                return reject(error);
            } // end if

            logger.info("Connected to %j", connectionInfo);

            var conn = new Connection(client, done);

            resolve(
                conn.getSettings()
                    .then(conn.getTypes.bind(conn))
                    .return(conn)
            );
        }); // end pg.connect callback
    }); // end Promise callback
} // end connect

// --------------------------------------------------------------------------------------------------------------------

/**
 * Wraps a PostgreSQL connection.
 *
 * @param {pg.Client} client - the `node-postgres` client
 * @param {function} done - the function to release the client to the `node-postgres` pool
 */
function Connection(client, done)
{
    this.client = client;
    this.done = done;
} // end Connection

util.inherits(Connection, events.EventEmitter);

/**
 * The definition of a PostgreSQL query.
 *
 * @typedef {object} Connection#QueryDef
 * @see {@link https://github.com/brianc/node-postgres/wiki/Prepared-Statements}
 *
 * @property {*} queryID - the ID of the query (an arbitrary value provided by the client)
 * @property {string} [name] - if supplied, creates or uses a prepared statement with the given name
 * @property {string} [text] - the text of the SQL query to run or prepare (required unless using a prepared statement)
 * @property {Array} [values] - the values of the query parameters
 */

/**
 * A row has been generated by a database query.
 *
 * @event Connection#row
 *
 * @param {*} queryID - the ID of the query that generated this row
 * @param {object} row - the row
 */

/**
 * An error occurred on this connection.
 *
 * @event Connection#error
 *
 * @param {object} error - the error that occurred
 */

Object.defineProperty(Connection.prototype, 'remoteAddress', {
    enumerable: true,
    get: function()
    {
        return this.client.connection.stream.remoteAddress;
    } // end get
}); // end '

/**
 * "Close" this connection.
 *
 * Actually, this releases the underlying client back to the to the `node-postgres` pool.
 */
Connection.prototype.close = function()
{
    this.done();

    delete this.client;
    delete this.done;
}; // end Connection#close

Connection.prototype.getSettings = function()
{
    var self = this;
    this.settings = {};
    this.settingDescriptions = {};
    var queryDef = {text: "SHOW ALL"};

    return this._query(queryDef, function(row)
    {
        self.settings[row.name] = row.setting;
        self.settingDescriptions[row.name] = row.description;
    })
    .then(function()
    {
        logger.debug("server settings = %s", logger.dump(self.settings));
        return self.settings;
    });
}; // end Connection#getSettings

Connection.prototype.getTypes = function()
{
    var self = this;
    this.types = {};
    var queryDef = {text: "SELECT t.oid, COALESCE(an.nspname, n.nspname) AS nspname, COALESCE(at.typname, t.typname) AS typname, t.typcategory, n.nspname, t.typname FROM pg_type t LEFT JOIN pg_namespace n ON n.oid = t.typnamespace LEFT JOIN pg_type at ON at.oid = t.typelem LEFT JOIN pg_namespace an ON an.oid = at.typnamespace WHERE t.typtype = 'b' ORDER BY t.oid"};

    return this._query(queryDef, function(row)
    {
        var typeOID = row.oid;
        var typeName = (row.nspname == 'pg_catalog' ? '' : row.nspname + '.') + row.typname +
            (row.typcategory == 'A' ? '[]' : '');

        self.types[typeOID] = typeName;

        switch(typeName)
        {
            case 'public.geometry':
                logger.debug("Setting type parser for data type %s (oid=%s) to that of `bytea`.",
                    logger.dump(typeName), logger.dump(typeOID));

                pgTypes.setTypeParser(typeOID, 'text', pgTypes.getTypeParser(byteaTypeOID));
                break;
        } // end switch
    })
    .then(function()
    {
        return self.types;
    });
}; // end Connection#getTypes

Connection.prototype._query = function(queryDef, onRow)
{
    var self = this;
    this.types = {};

    onRow = onRow || function(row, result)
    {
        result.addRow(row);
    }; // end default onRow;

    return new Promise(function(resolve, reject)
    {
        var query = self.client.query(queryDef)
            .on('error', onError)
            .on('row', onRow)
            .on('end', onEnd);

        function onError(error)
        {
            logger.error("Connection#_query got error: %s", error.stack || error);

            reject(error);

            query
                .removeListener('error', onError)
                .removeListener('row', onRow)
                .removeListener('end', onEnd);
        } // end onError

        function onEnd(result)
        {
            resolve(result);

            query
                .removeListener('error', onError)
                .removeListener('row', onRow)
                .removeListener('end', onEnd);
        } // end onEnd
    });
}; // end Connection#_query

/**
 * Execute a query on this PostgreSQL connection.
 *
 * @param {Connection#QueryDef} queryDef - the definition of the query to run
 *
 * @returns {Promise.<{rowCount: number, affectedRowCount: number, totalTimeMS: number}>} - a promise for the results
 *          object of the query once it's finished, with some extra information attached
 */
Connection.prototype.query = function(queryDef)
{
    var self = this;

    var queryID = queryDef.queryID;
    delete queryDef.queryID;
    queryDef.rowMode = "array";

    return new Promise(function(resolve, reject)
    {
        logger.info("Running query %j...", queryID);
        logger.trace("Query %j: %s", queryID, logger.dump(queryDef));

        var startTime = process.hrtime();
        var query = self.client.query(queryDef)
            .on('error', onError)
            .on('row', onRow)
            .on('end', onEnd);

        function onError(error)
        {
            logger.error("Query %j got error: %s", queryID, error.stack || error);

            reject(error);

            query
                .removeListener('error', onError)
                .removeListener('row', onRow)
                .removeListener('end', onEnd);
        } // end onError

        var fieldsEmitted = false;
        function emitFields(fields)
        {
            if(!fieldsEmitted)
            {
                self.emit('fields', queryID, fields.map(function(field)
                {
                    field.dataType = self.types[field.dataTypeID];
                    return field;
                }));

                fieldsEmitted = true;
            } // end if
        } // end emitFields

        function onRow(row, result)
        {
            emitFields(result.fields);

            result.returnedRowCount = (result.returnedRowCount || 0) + 1;

            self.emit('row', queryID, row);
        } // end onRow

        function onEnd(result)
        {
            var totalTime = process.hrtime(startTime);
            var totalTimeMS = totalTime[0] * 1e3 + totalTime[1] / 1e6;

            result.returnedRowCount = result.returnedRowCount || 0;

            logger.info("Query %j finished. (%s row%s returned, %s row%s affected)", queryID,
                result.returnedRowCount, result.returnedRowCount == 1 ? '' : 's',
                result.rowCount, result.rowCount == 1 ? '' : 's'
            );

            emitFields(result.fields);

            var response = _.assign(
                {
                    rowCount: result.returnedRowCount,
                    affectedRowCount: result.rowCount,
                    totalTimeMS: totalTimeMS
                },
                _.omit(result, 'returnedRowCount', 'rowCount', 'rows')
            );
            logger.trace("response: %s", logger.dump(response));

            resolve(response);

            query
                .removeListener('error', onError)
                .removeListener('row', onRow)
                .removeListener('end', onEnd);
        } // end onEnd
    }); // end Promise callback
}; // end Connection#query

// --------------------------------------------------------------------------------------------------------------------

module.exports = {
    connect: connect,
    Connection: Connection
};
